<!DOCTYPE html><html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <link href="./rebiere.css" rel="stylesheet">
    <script src="js/moment.min.js" language="JavaScript"></script>
    <script src="https://d3js.org/d3.v5.min.js" language="JavaScript"></script>
    <script src="js/liquidFillGauge.js" language="JavaScript"></script>
    <script src="js/floreal.js" language="JavaScript"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/1.3.7/chroma.min.js"></script>

</head>
<body>
    <div id="fullGrid">
        <div class="cell">
            <div class="header">temps républicain</div>
            <div class="data">
                <div class="value">
                    <div id="decimalClock"></div>
                    <div id="republicanDate"></div>
                </div>
            </div>
        </div>
        <div class="cell">
            <div class="header">niveau d'eau</div>
            <div class="data">
                <div id="waterGauge" class="value">
                    <svg id="waterLevelGauge" width="95%" height="95%"></svg>
                </div>
            </div>
        </div>
        <div class="cell">
            <div class="header">température ext.</div>
            <div id="temp" class="data">
                <span id="outdoorsTemperatureValue" class="weather value"></span>
                <sup class="unit">°c</sup>
            </div>
        </div>
        <div class="cell">
                <div class="header">température int.</div>
                <div class="data">
                    <span id="indoorsTemperatureValue" class="weather value">15</span>
                    <sup class="unit">°c</sup>
                </div>
            </div>
        <div class="cell" id="fullWeatherChartContainer">
            <div class="header">Cell 5</div>
            <div class="data" id="fullWeatherChart"></div>
        </div>
        <div class="cell">
            <div class="header">Cell 6</div>
            <div class="data"></div>
        </div>
        <div class="cell">
            <div class="header">Cell 7</div>
            <div class="data"></div>
        </div>
        <div class="cell">
            <div class="header">Cell 8</div>
            <div class="data"></div>
        </div>
        <div class="cell">
            <div class="header">Cell 9</div>
            <div class="data"></div>
        </div>
        <div class="cell">
            <div class="header">Cell 10</div>
            <div class="data"></div>
        </div>
    </div>
<script>
    const getLastValue = (data, key) => {
        let i = data.length - 1;
        let returnValue = data[i][key];
        while(!returnValue && i >= 0) returnValue = data[--i][key];
        return returnValue ? returnValue : -1;
    }

    const setTemperature = (selector, value) => {
        const elem = document.getElementById(selector);
        elem.innerHTML = value
        chromaScale = chroma
            .scale('RdYlBu')
            .domain([45, -30])
            .mode("lab")
        elem.style.color = chromaScale(value).hex();
    }

    const getDecimalTimeString = (d) => {
        let e = new Date(d);
        const sSinceMidnight = (d - e.setHours(0,0,0,0)) / 8460000;
        let dHour = Math.floor(sSinceMidnight);
        let dMinute = Math.floor(sSinceMidnight * 100 % 100);
        let dSecond = Math.floor(sSinceMidnight * 10000 % 100);
        return `${dHour}:${dMinute<10?`0${dMinute}`:dMinute}:${dSecond<10?`0${dSecond}`:dSecond}`
    }
    const tick = () => {
        document.getElementById('decimalClock').innerHTML = getDecimalTimeString(new Date())
    };

    tick();
    window.setInterval(tick, 842); //roughly one decimal second

    document.getElementById('republicanDate').innerHTML = new FlorealDate().toFullDateString()

    d3.timeFormatDefaultLocale({
        "decimal": ",",
        "thousands": " ",
        "grouping": [3],
        "currency": ["€", ""],
        "dateTime": "%a %b %e %X %Y",
        "date": "%d/%m/%Y",
        "time": "%H:%M:%S",
        "periods": ["AM", "PM"],
        "days": ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"],
        "shortDays": ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
        "months": ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
        "shortMonths": ["janv.", "févr.", "mars", "avril", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "dec."]
    });

    const options = {
        "sizes": {
            "width": 530,
            "height": 315,
            "wPad": 36,
            "hPad": 48
        },
        "axes": {
            "temperature": {
                "label": "Température",
                "unit": "°C",
                "colour": "red",
                "fillColour": "red",
                "line": {
                    "active": true,
                }
            },
            "pressure": {
                "label": "Pression",
                "unit": "hPa",
                "colour": "green",
                "fillColour": "green",
                "line": {
                    "active":true,
                }
            },
            "light": {
                "label": "Luminosité",
                "unit": "",
                "colour": "orange",
                "fillColour": "orange",
                "line": {
                    "active": true,
                }
            },
            "water": {
                "label": "Niveau d'eau",
                "unit": "cm",
                "colour": "steelblue",
                "fillColour": "lightblue",
                "line": {
                    "active": true,
                }
            },
        },
        "labelNames": ["timeLabel", "temperatureLabel", "pressureLabel", "lightLabel", "waterLabel"]
    }

    let fullChart = d3.select("#fullWeatherChart").append("svg")
    .attr("width", options.sizes.width + 2*options.sizes.wPad)
    .attr("height", options.sizes.height + 2*options.sizes.hPad)
    .append("g")
    .attr("transform", `translate(${options.sizes.wPad},5)`);

    // Get the data
d3.json("data.json").then((data) => {
    data = data.Items;

    // format the data
    const parseTime = d3.timeParse("%s");
    data.forEach(d => {
        d.timestamp = parseTime(d.timestamp);
        d.temperature = +d.temperature;
        d.pressure = +d.pressure;
        d.light = +d.light;
        d.waterLevel = +d.waterLevel;
    });
    // set the ranges
    const timeAxis = d3.scaleTime()
        .domain(d3.extent(data, d => d.timestamp ))
        .range([0, options.sizes.width]);
    const temperatureAxis = d3.scaleLinear()
        .domain([0, d3.max(data, d => Math.max(d.temperature) )])
        .range([options.sizes.height, 0]);
    const pressureAxis = d3.scaleLinear()
        .domain(d3.extent(data, d => d.pressure ))
        .range([options.sizes.height, 0]);
    const lightAxis = d3.scaleLinear()
        .domain([0, d3.max(data, d => Math.max(d.light) )])
        .range([options.sizes.height, 0]);
    const waterLevelAxis = d3.scaleLinear()
        .domain ([0, 400])
        .range([options.sizes.height, 0]);

    // Add the waterLine path and area.
    fullChart.append("path")
        .data([data])
            .attr("class", "water line")
            .style("fill", options.axes.water.fillColour)
            .style("stroke", options.axes.water.colour)
            .attr("d", d3.area()
                .curve(d3.curveStepAfter)
                .defined(d => d.waterLevel)
                .x(d => timeAxis(d.timestamp))
                .y0(options.sizes.height)
                .y1(d => waterLevelAxis(d.waterLevel)));

    // Add the temperatureLine path.
    fullChart.append("path")
        .data([data])
        .style("stroke", options.axes.temperature.colour)
        .attr("class", "temperature line")
        .attr("d", d3.line()
            .curve(d3.curveMonotoneX)
            .defined(d => d.temperature)
            .x(d => timeAxis(d.timestamp))
            .y(d => temperatureAxis(d.temperature)));

    // Add the pressureLine path.
    fullChart.append("path")
        .data([data])
        .style("stroke", options.axes.pressure.colour)
        .attr("class", "pressure line")
        .attr("d", d3.line()
            .curve(d3.curveMonotoneX)
            .defined(d => d.pressure)
            .x(d => timeAxis(d.timestamp))
            .y(d => pressureAxis(d.pressure)));

    // Add the lightLine path.
    fullChart.append("path")
        .data([data])
        .style("stroke", options.axes.light.colour)
        .attr("class", "light line")
        .attr("d", d3.line()
            .curve(d3.curveMonotoneX)
            .defined(d => d.light)
            .x(d => timeAxis(d.timestamp))
            .y(d => lightAxis(d.light)));

    // Add the X Axis
    fullChart.append("g")
        .attr("transform", `translate(0,${options.sizes.height})`)
        .call(d3.axisBottom(timeAxis));

    // Add the temperature Axis
    fullChart.append("g")
        .attr("class", "temperature axisRed")
        .call(d3.axisLeft(temperatureAxis));

    // Add the pressure Axis
    fullChart.append("g")
        .attr("class", "pressure axisGreen")
        .call(d3.axisRight(pressureAxis));

    // Add the water Axis
    fullChart.append("g")
        .attr("class", "water axisSteelBlue")
        .attr("transform", `translate(${options.sizes.width}, 0 )`)
        .call(d3.axisLeft(waterLevelAxis));

    // Add the light Axis
    fullChart.append("g")
        .attr("class", "light axisOrange")
        .attr("transform", `translate(${options.sizes.width}, 0 )`)
        .call(d3.axisRight(lightAxis));


    /*************************************************/
    /*             All the tooltip stuff             */
    /*************************************************/
    let tooltip = fullChart.append("g")
        .style("display", "none");

    // add the tooltip background
    tooltip.append("rect")
        .attr("rx", 6)
        .attr("ry", 6)
        .attr("id", "rectangleTooltip")
        .style("fill", "#0D47A1")
        .style("opacity", 0.9);

    // add the vertical line
    tooltip.append("line")
        .attr("id", "verticalTooltipLine")
        .style("stroke", "blue")
        .style("stroke-dasharray", "3,3")
        .style("opacity", 0.5)
        .attr("y1", 0)
        .attr("y2", options.sizes.height);

    // group all the labels so we can get their size later on
    let toolTipLabels = tooltip.append("g")
    toolTipLabels.selectAll("text")
        .data(options.labelNames)
        .enter()
        .append("text")
        .style("fill", "white")
        .attr("id", data => data);

    // append the rectangle to capture mouse
    fullChart.append("rect")
        .attr("width", options.sizes.width)
        .attr("height", options.sizes.height)
        .style("fill", "none")
        .style("pointer-events", "all")
        .on("mouseover", () => tooltip.style("display", null))
        .on("mouseout", () => tooltip.style("display", "none"))
        .on("mousemove", mousemove)
        .on("touchmove", mousemove);

    function mousemove() {
        const mouseX = d3.touches(this)[0] ? d3.touches(this)[0][0] : d3.mouse(this)[0];
        const mouseY = d3.touches(this)[0] ? d3.touches(this)[0][1] : d3.mouse(this)[1];
        const date = timeAxis.invert(mouseX);
        const formatTime = d3.timeFormat("%A %e %B, %H:%M");
        const bisectDate = d3.bisector(d => d.timestamp).left;
        const index = bisectDate(data, date);
        const temperature = data[index].temperature;
        const pressure = data[index].pressure;
        const light = data[index].light;
        const water = (index - 1 < 0) ? null : data[index - 1].waterLevel;

        tooltip.select("#verticalTooltipLine")
            .attr("transform", `translate(${mouseX},0)`);

        toolTipLabels.select(`#${options.labelNames[0]}`)
            .attr("transform", `translate(${mouseX + 30},${mouseY - 8})`)
            .text(formatTime(date));

        let i = 0;
        if (temperature) ++i;
        toolTipLabels.select(`#${options.labelNames[1]}`)
            .style("display", temperature ? null : "none")
            .attr("transform", `translate(${mouseX + 30},${mouseY + (16 * i)})`)
            .text(`Température : ${temperature}°C`);

        if (pressure) ++i;
        toolTipLabels.select(`#${options.labelNames[2]}`)
            .style("display", pressure ? null : "none")
            .attr("transform", `translate(${mouseX + 30},${mouseY + (16 * i)})`)
            .text(`Pression : ${pressure}hPa`);

        if (light) ++i;
        toolTipLabels.select(`#${options.labelNames[3]}`)
            .style("display", light ? null : "none")
            .attr("transform", `translate(${mouseX + 30},${mouseY + (16 * i)})`)
            .text(`Luminosité : ${light}`);

        if (water) ++i;
        toolTipLabels.select(`#${options.labelNames[4]}`)
            .style("display", water ? null : "none")
            .attr("transform", `translate(${mouseX + 30},${mouseY + (16 * i)})`)
            .text(`Niveau d'eau : ${water}cm`);
        const labelsBBox = toolTipLabels.node().getBBox();
        tooltip.select("#rectangleTooltip")
            .attr("transform", `translate(${labelsBBox.x - 15},${labelsBBox.y - 15})`)
            .attr("width", labelsBBox.width + 30)
            .attr("height", labelsBBox.height + 30);
    }

    /*************************************************/
    /*             All the legend stuff              */
    /*************************************************/
    var optionsList = d3.entries(options.axes);
    const legendRectSize = 18;
    const legendSpacing = 4;
    let legend = fullChart.selectAll('.legend')
        .data(optionsList)
        .enter()
        .append('g')
        .on("click", d => {
            d.value.line.active = !d.value.line.active;
            d3.selectAll(`.${d.key}`)
                .style("opacity", d.value.line.active ? 1 : 0.1);
        })
        .attr('class', 'legend')
        .attr('transform', (d, i) => `translate(${ i * 120},${options.sizes.height + 30})`)
    legend.append('rect')
        .attr("class", d => d.key)
        .attr('width', legendRectSize)
        .attr('height', legendRectSize)
        .style('fill', d => d.value.fillColour)
        .style('stroke', d => d.value.colour);
    legend.append('text')
        .attr("class", d => d.key)
        .attr('x', legendRectSize + legendSpacing)
        .attr('y', legendRectSize - legendSpacing)
        .text(d => `${d.value.label}${d.value.unit?` (${d.value.unit})`:''}`);

    let liquidFillGaugeConfig = liquidFillGaugeDefaultSettings();
    liquidFillGaugeConfig.minValue = 0;
    liquidFillGaugeConfig.maxValue = 400;
    liquidFillGaugeConfig.displayPercent = false;
    liquidFillGaugeConfig.waveAnimateTime = 10000;
    loadLiquidFillGauge("waterLevelGauge", getLastValue(data, "waterLevel"), liquidFillGaugeConfig);
    setTemperature("outdoorsTemperatureValue", Math.round( getLastValue(data, "temperature") * 10 ) / 10)
    setTemperature("indoorsTemperatureValue", 0.00)

});
</script>
</body>
</html>
